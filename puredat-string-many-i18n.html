<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-pages/iron-pages.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../puredat-paper-input-autocomplete-chips/paper-input-autocomplete-chips.html">
<link rel="import" href="../paper-tabs/paper-tabs.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<!--
	`puredat-string-many-i18n` "STRING" type, "ONE" cardinality, and "I18N" widget.
	
	@demo demo/index.html 
-->
<dom-module id="puredat-string-many-i18n">
	<template>
		<style>
			paper-spinner {
				position: absolute;
				margin-top: -45px;
				margin-left: 10px;
			}
			
			paper-tabs {
				--paper-tabs-selection-bar-color: var(--accent-color);
				padding-right: 10px;
				font-size: 12px;
				height: 35px;
				
				--paper-tabs-selection-bar: {
					bottom: 6px;
				}				
			}
			
			paper-input-autocomplete-chips {
				--paper-input-container: {
					padding-right: 10px;
				}
			}
			
			paper-icon-button {
				position: absolute;
				right: 0;
				bottom: 0;
			}
			
			paper-tabs {
				--paper-tabs-selection-bar-color: var(--default-primary-color);
			}
		</style>
		
		<iron-ajax id="ajax"
				on-response="responseHandler"
				url="https://api.mymemory.translated.net/get"
				method="GET"
				verbose="false">
		</iron-ajax>

		<div style="display: flex">
			<span style="height: 10px; font-size: 12px; color: #757575; padding-top: 10px; flex: 1">[[label]]</span>

			<paper-tabs 
					id="languageTabs"
					noink 
					selected="{{selected}}">

				<template is="dom-repeat" items="[[supportedLanguages]]">
					<paper-tab active$="[[isSelected(index)]]">{{item}}</paper-tab>
				</template>
			</paper-tabs>
		</div>
		
		<iron-pages selected="{{selected}}">
			<template is="dom-repeat" items="[[supportedLanguages]]">
				<paper-input-autocomplete-chips
						tabindex="-1"
						no-chip-image
						no-label-float
						type="text"
						maxlength="[[maxLength]]"
						max-selected-items="100"
						label="[[label]]"
						readonly$="[[readOnly]]"
						error-message="[[errorMessage]]"
						invalid="[[_isInvalid(errorMessage)]]"
						allowed-pattern="[[pattern]]"
						allow-select-unknown-token
						on-selected-objects-changed="_newValue"
						data-lng$="{{item}}">
					<paper-icon-button 
							suffix 
							title="Traducir" 
							icon="translate"
							disabled$="[[readOnly]]" 
							on-click="translateHandler"
							data-lng$="{{item}}">
					</paper-icon-button>
				</paper-input-autocomplete-chips>
			</template>
		</iron-pages>
		<paper-spinner active$="[[isSpinnerActive(_pendingCount)]]"></paper-spinner>
	</template>
	
	<script>
		Polymer({
			is: 'puredat-string-many-i18n',
			
			properties: {
				
				_pendingCount: {
					type: Number,
					value: 0
				},
				
				selected: {
					type: Number,
					value: 0
				},

				supportedLanguages: {
					type: Array
				},
				
				value: {
					type: Object,
					observer: '_valueChanged'
				},
				
				/** Name */
				name: {
					type: String
				},
				
				/** Maximum length. */
				maxLength: {
					type: Number,
					value: 100
				},
				
				/** Allowed pattern. For example: [a-zA-Z]. */
				pattern: {
					type: String
				},
				
				/** Descriptive label. */
				label: {
					type: String
				},
				
				/** Error message. */
				errorMessage: {
					type: String
				},
				
				/** Number of columns in a row of 10 columns. */
				cols: {
					type: Number,
					value: 5,
					observer: '_colsChanged'
				},
				
				/** Read only. */
				readOnly: {
					type: Boolean,
					value: false
				}
			},

			_valueChanged: function(value){
				var elements = Polymer.dom(this.root).querySelectorAll("paper-input-autocomplete-chips");
				for(var i = 0;i < elements.length;i++){
					var element = elements[i];
					if(element && element.getAttribute("data-lng")){
						var elementLng = element.getAttribute("data-lng");
						if(this.value && this.value[elementLng]){
							var tmp = [];
							for(var j = 0;j < this.value[elementLng].length;j++){
								tmp.push({text:this.value[elementLng][j]});
							}

							if(tmp.length != element.selectedObjects.length){
								element.selectedObjects = tmp;
							}else{
								var same = true;

								for(var j = 0;j < element.selectedObjects.length;j++){
									if(tmp.indexOf(element.selectedObjects[j].text) < 0){
										same = false;
									}
								}

								if(!same) element.selectedObjects = tmp;
							}
						}else{
							if(element.selectedObjects.length != 0) element.selectedObjects = [];
						}
					}
				}

				console.log(this.value);
			},

			_cloneValue: function(){
				var cloneVal = {};
				if(this.value){
					for(var key in this.value){
						cloneVal[key] = this.value[key] ? this.value[key].slice() : [];
					}
				}

				return cloneVal;
			},

			_newValue: function(event){
				var tmpValue = this._cloneValue();

				if(event.srcElement || event.target){
					var src = event.srcElement || event.target;
					var lng = src.getAttribute("data-lng");
					if(lng && src.selectedObjects){
						var tmpElements = src.selectedObjects.slice();
						tmpValue[lng] = [];
						for(var i = 0;i < tmpElements.length; i++){
							if(tmpElements[i].text) tmpValue[lng][i] = tmpElements[i].text;
						}
					}
				}

				var finalValue = this._correctValue(tmpValue);

				if(!(JSON.stringify(this.value) === JSON.stringify(finalValue))){
					for(var key in this.value) this.value[key] = finalValue && finalValue[key] ? finalValue[key] : [];
					this.set("value", this.value);
				}
			},

			_correctValue: function(value){
				var tmpValue = value;

				if(tmpValue){
					var hasValues = false;
					var toDelete = [];
					for(var key in tmpValue){
						if(tmpValue[key] != null && tmpValue[key].length > 0){
							hasValues = true;
						}else{
							toDelete.push(key);
						}
					}

					if(!hasValues){
						tmpValue = null;
					}else{
						for(var i = 0;i < toDelete.length;i++){
							delete tmpValue[toDelete[i]];
						}
					}
				}

				return tmpValue;
			},

			_getLangValue: function(value,code){
				return this.value ? (this.value[code] ? this.value[code] : null) : null;
			},
			
			isSpinnerActive: function(pendingCount) {
				return (pendingCount > 0);
			},
			
			translateHandler: function(event) {
				if(event.srcElement || event.target){
					var src = event.srcElement || event.target;

					var baseLanguage = src.getAttribute("data-lng") || (src.parentNode ? src.parentNode.getAttribute("data-lng") : null);
					
					if (this.supportedLanguages != null
							&& this.supportedLanguages.length > 0 && baseLanguage && this.value[baseLanguage]) {
						var baseValue = this.value[baseLanguage];
						
						for (var i = 0; i < this.supportedLanguages.length; i++) {
							var languageCode = this.supportedLanguages[i];
							if (languageCode != baseLanguage) {
								for(var j = 0;j < baseValue.length;j++){
									this.$.ajax.params["q"] = baseValue[j];
									this.$.ajax.params["langpair"] = baseLanguage.split("_")[0] + "|" + languageCode.replace("_", "-");
									this.$.ajax.params["non-related-index"] = j;
									this.$.ajax.generateRequest();
									this._pendingCount++;
								}
							}
						}
					}
				}
			},
			
			responseHandler: function(event, request) {
				this._pendingCount--;
				if (event.detail.succeeded) {
					if (event.detail.response != null
							&& event.detail.response.matches != null
							&& event.detail.response.matches.length > 0) {
						var searchParams = new URLSearchParams(request.url);
						var value = {};
						for (var i = 0; i < this.supportedLanguages.length; i++) {
							if (this.supportedLanguages[i] == searchParams.get("langpair").split("|")[1].replace("-", "_")) {
								if(!value[this.supportedLanguages[i]]) value[this.supportedLanguages[i]] = [];
								value[this.supportedLanguages[i]][searchParams.get("non-related-index")] = event.detail.response.responseData.translatedText;
							}
						}

						var finalValue = this._correctValue(value);
						if(!JSON.stringify(this.value) === JSON.stringify(finalValue)){
							for(var key in this.value) this.value[key] = finalValue[key] ? finalValue[key] : [];
							this.set("value", this.value);
						}
					}
				}
			},
			
			isSelected: function(number) {
				return number == 0;
			},
			
			_colsChanged: function(newValue, oldValue) {
				this.style.minWidth = (30 * newValue) + "px";
				this.style.flex = "0 0 " + (10 * newValue) + "%";
			},
			
			/**
			 * Returns if the field is valid.
			 * @param {String} errorMessage The error message.
			 * @return {Boolean} If the input field is valid.
			 */
			_isInvalid: function(errorMessage) {
				return errorMessage != null
						&& errorMessage != "";
			}
		});
	</script>
</dom-module>
